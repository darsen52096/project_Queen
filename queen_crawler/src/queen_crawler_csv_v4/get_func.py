# This modul is generated by dataframes.py

import csv
import re
import shutil
from datetime import datetime
from datetime import timedelta
from datetime import date
import sys


sys.path.insert(0, "/home/arsen52096/projects_Arsen/project_Queen/queen_crawler/src/")
from common import *


def input_value(name_of_value, type_of_value):
    """
    Ввод данных в ручную
    """
    print("Введите значение '" + name_of_value + "'")
    if type_of_value == 'Float_Value':
        value = float(input())
    elif type_of_value == 'Integer_Value':
        value = int(input())
    else:
        value = str(input())
    return value



def get_name_of_passport(lists):
    """ Извлечение наименования паспорта """
    """ Горизонтальное парсирование """
    print('Extracting name_of_passports...')
    name_of_passports = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'Номер паспорта'
    
    for my_file_list in my_file_lists:
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_name_of_passport = int(my_file_list.index(result))
        name_of_passport = str(my_file_list[index_name_of_passport + 1])
        name_of_passports.append(name_of_passport)

    print('Extracted values (Номер паспорта): '+ str(len(name_of_passports)))
    return name_of_passports


def get_date_of_passport(lists):
    """ Извлечение даты составления паспорта """
    """ Горизонтальное парсирование """
    date_of_passports = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    # паттерн шаблон для регулярного выражения
    pattern_text = r'\d\d\d\d\d.\d'
    
    for my_file_list in my_file_lists:
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        # в объекте string убираем значение .0
        result = result.replace('.0', '')
        # переклассифицируем объект str в объект int
        result = int(result)
        date_of_passports.append(result)
    print('Extracted values (Дата составления паспорта): '+ str(len(date_of_passports)))
    return date_of_passports


def get_certification_name(lists):
    """ Извлечение наименований сертификата """
    """ Горизонтальное парсирование """

    # паттерн шаблон для регулярного выражения
    pattern_text = r'Номер сертификата..*'
    print('Extracting certification_name...')
    certification_names = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    for my_file_list in my_file_lists:
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_certification_name = int(my_file_list.index(result))
        certification_name = str(my_file_list[index_certification_name + 1])
        certification_names.append(str(certification_name))
    print('Extracted values (Наименование сертификата): '+ str(len(certification_names)))
    return certification_names


def name_contracts(lists, type_of_information)-> list:
    """ Извлечение сведений по договору """
    """ Извлекается номер договора """
    """ Извлекается дата договора """
    """ Горизонтальное парсирование """

    name_of_contracts, date_of_contracts  = [], []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'\w+\sдоговора пере..*'
    
    for my_file_list in my_file_lists:

        # первый элемент вхождения
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_of_contract = int(my_file_list.index(result))
        contract = my_file_list[index_of_contract + 1]

        # добавление наименования договора вместе с датой
        name_of_contracts.append(contract)

        # извлечение из переменной name_of_contracts переменную date
        # на выходе тип данных list
        date = re.findall(r'\d{2}.\d{2}.\d{4}', contract)
        # перевод из list в str
        date = " ".join(date)

        # вычленение из name_of_contracts номера договора с помощью переменной date
        name_of_contracts = [x.replace(date,'') for x in name_of_contracts]
        name_of_contracts = [x.replace(' от ','') for x in name_of_contracts]
        name_of_contracts = [x.replace('от','') for x in name_of_contracts]

        date_of_contracts.append(date)

    # удаление дупликатов

    name_of_contracts = list(set(name_of_contracts))
    date_of_contracts = list(set(date_of_contracts))

    if type_of_information == 'name_of_contract':
        print('Extracted values (Номер договора): '+ str(len(name_of_contracts)))
        return name_of_contracts
    elif type_of_information == 'date':
        print('Extracted values (Дата составления договора): '+ str(len(date_of_contracts)))
        return date_of_contracts


def id_bags(lists):
    """ Извлечение индивидуального номера упаковки (партии) РАО (идентификационный код) """
    print('Extracting id_bags...')
    id_bags = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'Индивидуальный номер..*'
    for my_file_list in my_file_lists:
        # бывает как у Звездочки, 'идентификационный' код стоит особняком (отдельной строкой)
        # удаляем его (метод remove удаляет первый элемент в списке)
        try:
            my_file_list.remove('(идентификационный код)')
        except ValueError:
            None
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_id_bag = int(my_file_list.index(result))
        id_bag = str(my_file_list[index_id_bag + 1])        
        # очистка данных
        id_bag = id_bag.split('.')[0]
        id_bag = id_bag.split('№ ')[-1]
        id_bags.append(str(id_bag))
    print('Extracted values (Индивидуальный номер): '+ str(len(id_bags)))
    return id_bags




def organisations_of_bags(type_of_organisation, lists):
    """ Функция для извлечения данных по наименованиям организаций-собственников 
    и организаций-изготовителей упаковок РАО """
    print('Extracting organisations_of_bags...')
    organisations = []

    if type_of_organisation == 'собственник':
        pattern_text = r'Организация-собственник..*'
    elif type_of_organisation == 'изготовитель':
        pattern_text = r'Организация-изготовитель..*'
    
    my_file_lists = open_and_read_csv_files_hor(lists)
    for my_file_list in my_file_lists:
        # замена наименований организаций
        my_file_list = [str(i).replace('АО «ЭКОМЕТ-С»  ОКПО 34371127 ( статус РАО - 34371127)', 'АО «ЭКОМЕТ-С»') for i in my_file_list]
        my_file_list = [str(i).replace('Филиал АО "Концерн Росэнергоатом" "Балаковская атомная станция"', 'Балаковская АЭС') for i in my_file_list]
        my_file_list = [str(i).replace('Федеральное государственное унитарное предприятие атомного флота (ФГУП "Атомфлот") ОКПО 01127056', 'ФГУП "Атомфлот"') for i in my_file_list]
        my_file_list = [str(i).replace('Акционерное общество «Сибирский химический комбинат» ', 'АО "СХК"') for i in my_file_list]
        my_file_list = [str(i).replace('Филиал АО "Концерн Росэнергоатом" "Курская атомная станция" (Курская АЭС) ОКПО 57466221', 'Курская АЭС') for i in my_file_list]
        my_file_list = [str(i).replace('Военно-Морской Флот Российской Федерации (поставщик - АО "ЦС "Звездочка" ОКПО 07515753) Код "статус РАО" - 2', 'ЦС Звездочка') for i in my_file_list]
        my_file_list = [str(i).replace('Филиал АО "Концерн Росэнергоатом" "Смоленская атомная станция" (Смоленская АЭС) ОКПО 25798559', 'Смоленская АЭС') for i in my_file_list]
        my_file_list = [str(i).replace('Свердловское отделение филиала "Уральский территориальный округ" ФГУП "РосРАО"', 'Свердловское РосРАО') for i in my_file_list]
        my_file_list = [str(i).replace('Общество с ограниченной ответственностью по монтажу и наладке радиационной техники "Квант"', 'Квант') for i in my_file_list]
        my_file_list = [str(i).replace('Федеральное государственное унитарное предприятие «Объединенный эколого-технологический и научно-исследовательский центр по обезвреживанию РАО и охране окружающей среды» (ФГУП «РАДОН») ОКПО 05083841', 'ФГУП «РАДОН»') for i in my_file_list]
        my_file_list = [str(i).replace('АО "ЭКОМЕТ-С" ОКПО 343711271', 'АО «ЭКОМЕТ-С»') for i in my_file_list]
        my_file_list = [str(i).replace('АО "ЭКОМЕТ-С" ОКПО 34371127', 'АО «ЭКОМЕТ-С»') for i in my_file_list]
        my_file_list = [str(i).replace('Общество с ограниченной ответственностью "Алаид" ОКПО 46670131', 'ООО «Алаид»') for i in my_file_list]

        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_of_organisation = int(my_file_list.index(result))
        organisation_owner_bag = my_file_list[index_of_organisation + 1]
        organisations.append(organisation_owner_bag)
    print('Extracted values ('+str(type_of_organisation)+'): '+ str(len(organisations)))
    return organisations

def type_of_bag(lists):
    """ Функция для извлечения данных по наименованию типов упаковок РАО """
    print('Extracting type_of_bag...')
    name_of_bags = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    for my_file_list in my_file_lists:
        # замена наименований контейнеров для систематизации
        my_file_list = [str(i).replace('НЗК-Радон', 'НЗК-РАДОН') for i in my_file_list]
        # my_file_list = [str(i).replace('КРАД-1,36', 'КРАД-1,36') for i in my_file_list]

        pattern_text = r'Наименование'
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        
        index_of_type_bags = int(my_file_list.index(result))
        type_bag = my_file_list[index_of_type_bags + 1]
        
        type_bag = type_bag.split(' №')[0]
        type_bag = type_bag.split(' М')[0]
        # лишний пробел выскакивает
        type_bag = type_bag.split(' ')[0]

        name_of_bags.append(type_bag)
    print('Extracted values (' + str(result) + ' типов упаковок): '+ str(len(name_of_bags)))
    return name_of_bags

def parsing_code(lists):
    """ Функция для извлечения 11-значного кода РАО """
    print('Extracting code_of_RAO...')
    values_of_code = []
    my_file_lists = open_and_read_csv_files_ver(lists)
    for my_file_list in my_file_lists:
        # делю спсисок на две части, чтобы парсинг шел с графы "Код и класс РАО"
        # нужно быть уверенным что так графа "Код и класс РАО" существует
        my_file_list = ' '.join(my_file_list)
        my_file_list = [my_file_list.split('Класс и код РАО')[1]]
        # ^ и $ начало и конец строки соответственно
        # print(my_file_list)
        pattern_text = r'\d{11}'
        # временно ставлю данный текст пока проверяю 10 значный код 20.07.2020
        # pattern_text = r'\d{10}'
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        values_of_code.append(result)
    print('Extracted values (Код РАО): '+ str(len(values_of_code)))
    return values_of_code

def parsing_values(key: str, type_of_measure: str, lists, block_of_information):
    """ Функция для распознования значений масс и объемов """
    """ key: масса или объем,
        type_of_measure: брутто или нетто
        block_of_information: для каких целей требуется функция """
    print('Extracting '+str(key)+' '+str(type_of_measure)+'...')
    values_of_mass_RAO, values_of_volume_RAO = [], []
    my_file_lists = open_and_read_csv_files_ver(lists)
    # на случай, если вертикальное парсирование не поможет
    my_file_lists_another = open_and_read_csv_files_hor(lists)

    if type_of_measure == 'брутто':
        pattern_text = r'Упаковки..*'
    elif type_of_measure == 'нетто':
        pattern_text = r'РАО в упаковке'
    # включаю счетчик, если понадобится горизонтальное парсирование
    i = 0
    for my_file_list in my_file_lists:

        # Экомет-С любит такую шнягу включать
        my_file_list = [str(i).replace(' -)*', '') for i in my_file_list]
        # апостраф мешает работе парсера, избавляемся от него
        my_file_list = [str(i).replace('РАО в упаковке 2)', 'РАО в упаковке') for i in my_file_list]
        my_file_list = [str(i).replace('РАО в упаковке2)', 'РАО в упаковке') for i in my_file_list]
        my_file_list = [str(i).replace('РАО в упаковке3) 4)', 'РАО в упаковке') for i in my_file_list]
        my_file_list = [str(i).replace('РАО в упаковке3)', 'РАО в упаковке') for i in my_file_list]

        # print(my_file_list)  
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)

        index_of_value = int(my_file_list.index(result))
        value_of_mass = my_file_list[index_of_value+2]

        # если в исходном файле слэш находится рядом с нужным значением
        value_of_mass = value_of_mass.replace('\\', '')

        # значение массы (брутто/нетто) содержит запятую
        value_of_mass = value_of_mass.replace(',', '.')

        try:
            # если значение объема находится снизу от массы
            value_of_volume = str(my_file_list[index_of_value+3])
            value_of_volume = value_of_volume.replace(',', '.')
            value_of_volume = value_of_volume.replace('(', '')
            value_of_volume = value_of_volume.replace(')', '')
            value_of_volume = value_of_volume.replace('/', '')
            #2 обратных слэша питон интепретирует как один
            value_of_volume = value_of_volume.replace('\\', '')
            value_of_volume = float(value_of_volume)
        except:
            # на случай, если вертикальное парсирование не поможет
            # my_file_lists_another = open_and_read_csv_files_hor(lists)
            # если значение объема находится правее от значения массы
            my_file_list_another = my_file_lists_another[i]
            # защита от кривых наборов значений
            index_of_value = int(my_file_list_another.index(value_of_mass))
            value_of_volume = str(my_file_list_another[index_of_value+1])
            # оочень костыльное решение
            value_of_mass = value_of_mass.replace(' /', '')
            value_of_mass = value_of_mass.replace('/', '')

            value_of_volume = value_of_volume.replace(',', '.')
            value_of_volume = value_of_volume.replace('(', '')
            value_of_volume = value_of_volume.replace(')', '')
            value_of_volume = value_of_volume.replace('/', '')
            value_of_volume = value_of_volume.replace('\\', '')
            # преобразование строки в число
            value_of_volume = float(value_of_volume)
        i+= 1
        values_of_mass_RAO.append(float(value_of_mass))
        values_of_volume_RAO.append(value_of_volume)

    mass_and_volume = {
        'масса': values_of_mass_RAO,
        'объем': values_of_volume_RAO,
    }

    # используем нижеуказанную конструкцию для подчета итоговых значений в акте приема-передач
    if key == 'объем' and type_of_measure == 'брутто' and block_of_information == 'act_of_transfer':
        
        sumOfElements = 0
        for element in mass_and_volume['объем']:
            sumOfElements = sumOfElements + element
        return sumOfElements
    else:
        print('Extracted values ('+str(key)+', '+str(type_of_measure)+'): '+ str(len(mass_and_volume[key])))
        return mass_and_volume[key]






def parsing_general_activity(lists):
    """
    Парсирование общей активности.
    Вертикальное парсирование.
    """
    print('Extracting general activity...')
    values_of_general_activation = []
    my_file_lists = open_and_read_csv_files_ver(lists)
    for my_file_list in my_file_lists:
        pattern_text = r'Общая активность.*'
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_of_activity = int(my_file_list.index(result))
        general_activity = float(my_file_list[index_of_activity + 2])
        values_of_general_activation.append(general_activity)
    print('Extracted values (Общая активность): '+ str(len(values_of_general_activation)))
    return values_of_general_activation

def parsing_specific_activity(type_of_radiation: str, lists):
    """
    Парсирование удельных активностей.
    Горизонтальное парсирование.
    """
    print('Extracting '+str(type_of_radiation)+'...')
    specific_activitys = []    
    my_file_lists = open_and_read_csv_files_hor(lists)
    
    if type_of_radiation == 'долгоживущие':
        pattern_text = r'долгоживущие'
    elif type_of_radiation == 'трансурановые':
        pattern_text = r'трансурановые'
    elif type_of_radiation == 'альфа-излучающие':
        pattern_text = r'альфа-излучение'
    elif type_of_radiation == 'бета/гамма излучающие':
        pattern_text = r'бета/гамма-излучение'
    elif type_of_radiation == 'тритий':
        pattern_text = r'тритий'

    for my_file_list in my_file_lists:
        # re.search схватывает первое вхождение значения: очень ВАЖНО!!!!
        # метод re.search ищет по всей строке, но возвращает только первое значение
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_of_special_activity = int(my_file_list.index(result))
        try:
            special_activity = float(my_file_list[index_of_special_activity + 1])
        except:
            special_activity = 0
        specific_activitys.append(special_activity)
        # когда есть первичные упаковки, цикл будет схватывать первое значение
    print('Extracted values ('+str(type_of_radiation)+'): '+ str(len(specific_activitys)))
    return specific_activitys

def parsing_nuclids(lists):
    """
    Функция для извлечения данных по нуклидам и динамического парсирования сведений по нуклидам
    """
    # для парсинга нуклидов
    nuclids_in_file = []
    # для парсинга активностей нуклидов для каждого файла
    values_of_activity_nuclid = []
    # для парсинга активностей нуклидов
    values_of_activity_nuclids = []
    # формирование списка нуклидов из установленного словаря
    nuclids = [nuclid for nuclid in dict_of_criteria_of_RAO_1069.keys()]
    my_file_lists = open_and_read_csv_files_hor(lists)
    for nuclid in nuclids:
        print('Extracting '+str(nuclid)+'...')
        values_of_activity_nuclid = []
        nuclids_in_file.append(nuclid)
        for my_file_list in my_file_lists:
            my_file_list = [str(i).replace('Уран – 234', 'U-234') for i in my_file_list]
            my_file_list = [str(i).replace('Уран – 235', 'U-235') for i in my_file_list]
            my_file_list = [str(i).replace('Уран – 238', 'U-238') for i in my_file_list]
            my_file_list = [str(i).replace('U – 234', 'U-234') for i in my_file_list]
            my_file_list = [str(i).replace('U – 235', 'U-235') for i in my_file_list]
            my_file_list = [str(i).replace('U – 238', 'U-238') for i in my_file_list]
            if nuclid in my_file_list:
                pattern_text = r''+str(nuclid)+''
                # re.search схватывает первое вхождение значения по нуклиду: очень ВАЖНО!!!!
                result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
                result = result.group(0)
                index_of_nuclid = int(my_file_list.index(nuclid))
                value_of_nuclid = float(my_file_list[index_of_nuclid+1])
                values_of_activity_nuclid.append(value_of_nuclid)
            else:
                values_of_activity_nuclid.append(0)
        print('Extracted values ' + str(nuclid) + ': ' + str(len(values_of_activity_nuclid)))
        values_of_activity_nuclids.append(values_of_activity_nuclid)
    # zip to iterate over two lists in parallel
    dict_of_nuclids_activity = {
    radionucklid : activity_value for radionucklid, activity_value in zip(nuclids_in_file, values_of_activity_nuclids)
    }
    return dict_of_nuclids_activity


def parsing_dates_of_measure_activity(lists):
    """ Функция для извлечения данных по датам измерения удельных активностей радионуклидов """
    # используется для подсчета удельных активностей на момент подписания актов приема-передач
    print('Extract dates_of_measure_activity...')
    dates_of_measures = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'активность приведена..*'
    for my_file_list in my_file_lists:
        date = 0
        # удаление последнего пробельного итерала \n
        my_file_list = [line.rstrip() for line in my_file_list]
        my_file_list = [str(i).replace('Дата измерения -',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('значения активности приведены на',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('Дата измерения (расчета) активности упаковки РАО',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('Активность приведена на',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('Активность определена на',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('Удельная активность радионуклидов в упаковке РАО приведена на',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('Дата измерения (расчета) -',
             'активность приведена на') for i in my_file_list]
        my_file_list = [str(i).replace('Радиационные параметры приведены на',
             'активность приведена на') for i in my_file_list]
        # замена пробельного литерала на пустоту
        my_file_list = [str(i).replace('\n', ' ') for i in my_file_list]
        # разворачиваем список для того, чтобы дата измерения нужная выхватывалась
        my_file_list = my_file_list[::-1]
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_of_dates = int(my_file_list.index(result))
        try:
            # если дата является датой в excel
            date = float(my_file_list[index_of_dates - 1])
            date = datetime(*xlrd.xldate_as_tuple(date, 0))
            date = datetime.date(date)
            date = date.strftime('%d.%m.%Y')
        except:
            # если дата является строкой
            date = str(my_file_list[index_of_dates - 1])
            date = date.split('г.')[0]
            date = datetime.strptime(date, '%d.%m.%Y')
            date = date.strftime('%d.%m.%Y')
        dates_of_measures.append(date)
    print('Extracted values (Дата измерения активности): '+ str(len(dates_of_measures)))
    return dates_of_measures

def parsing_dates_of_delivery_RAO(lists):
    """
    Извлечение сведений - дата передачи упаковки РАО на захоронение РАО
    """
    print('Extract dates_of_measure_activity...')
    dates_of_delivery = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'Дата передачи упаковки..*'
    for my_file_list in my_file_lists:
        result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
        result = result.group(0)
        index_of_dates = int(my_file_list.index(result))
        try:
            # если дата является датой в excel
            date = float(my_file_list[index_of_dates + 1])
            date = datetime(*xlrd.xldate_as_tuple(date, 0))
            date = datetime.date(date)
            date = date.strftime('%d.%m.%Y')
        except:
            date = str('Не принято')
        dates_of_delivery.append(date)
    print('Extracted values (Дата передачи упаковки (партии) РАО на захоронение): '+ str(len(dates_of_delivery)))
    return dates_of_delivery

def get_filling_number(lists):
    """ Извлечение сведений - номер пломбировочного устройства """
    print('Extract filling_number...')
    fillings_number = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'Тип и идентификатор..*'
    for my_file_list in my_file_lists:
        try:
            result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
            result = result.group(0)
            index_filling_number = int(my_file_list.index(result))
            filling_number = str(my_file_list[index_filling_number + 1])
        except:
            filling_number = str('не установлено')
        fillings_number.append(filling_number)
    print('Extracted values (Номер пломбировочного устойства): ' + str(len(filling_number)))
    return fillings_number

def get_status_RAO(lists):
    """ Извлечение сведений - статус РАО """
    print('Extact status RAO...')
    status_RAO = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'Код "Статус Р.*'
    for my_file_list in my_file_lists:
        try:
            result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
            result = result.group(0)
            index_status = int(my_file_list.index(result))
            status = str(my_file_list[index_status + 1])
        except:
            status = str('не установлено')
        status_RAO.append(status)
    print('Extracted values (Статус РАО): ' + str(len(status_RAO)))
    return status_RAO


def parsing_date_of_manufacture_of_RAW_package(lists):
    """ Извлечение сведений - даты изготовления упаковок РАО """
    print('Дата изготовления упаковки РАО...')
    date_of_manufacture_of_RAW_package = []
    my_file_lists = open_and_read_csv_files_hor(lists)
    pattern_text = r'Дата изготовления упаковк.*'
    for my_file_list in my_file_lists:
        try:
            result = [re.search(pattern_text, string) for string in my_file_list if re.search(pattern_text, string) is not None][0]
            result = result.group(0)
            index_of_dates = int(my_file_list.index(result))
            try:
                # если дата является датой в excel
                date = float(my_file_list[index_of_dates + 1])
                date = datetime(*xlrd.xldate_as_tuple(date, 0))
                date = datetime.date(date)
                date = date.strftime('%d.%m.%Y')
            except:
                # если дата является строкой
                date = str(my_file_list[index_of_dates - 1])
                date = date.split('г.')[0]
                date = datetime.strptime(date, '%d.%m.%Y')
                date = date.strftime('%d.%m.%Y')
        except:
            date = str('не установлено')
        date_of_manufacture_of_RAW_package.append(date)
    print('Extracted values (Дата изготовления упаковки РАО): ' + str(len(date_of_manufacture_of_RAW_package)))
    return date_of_manufacture_of_RAW_package



"""
# форматирование альфа-излучающих
flat_list = [str(i).replace('α-изл. (без тр./у) ', 'альфа-излучение') for i in flat_list]
flat_list = [str(i).replace('альфа-изл. (за искл. т/уран.)', 'альфа-излучение') for i in flat_list]
flat_list = [str(i).replace('a-изл. (без тр./у)', 'альфа-излучение') for i in flat_list]
flat_list = [str(i).replace('α-изл. (без тр./у)', 'альфа-излучение') for i in flat_list]
flat_list = [str(i).replace('альфа-изл.(за искл. т/уран.)', 'альфа-излучение') for i in flat_list]

# форматирование бета/гамма-излучающих
flat_list = [str(i).replace('бета/гамма - изл.', 'бета/гамма-излучение') for i in flat_list]
flat_list = [str(i).replace('β/γ-излучающие', 'бета/гамма-излучение') for i in flat_list]
flat_list = [str(i).replace('бета/гамма- изл.', 'бета/гамма-излучение') for i in flat_list]
flat_list = [str(i).replace('b/g-излучающие', 'бета/гамма-излучение') for i in flat_list]
flat_list = [str(i).replace('β/γ-излучающие', 'бета/гамма-излучение') for i in flat_list]

# форматирование долгоживущих радионуклидов
flat_list = [str(i).replace('долгоживущие ', 'долгоживущие') for i in flat_list]
flat_list = [str(i).replace('долгоживу-щие', 'долгоживущие') for i in flat_list]
flat_list = [str(i).replace('трансурано-вые', 'трансурановые') for i in flat_list]

# такую хуйню РосРАО может сморозить (русская "С"), да и не только РосРАО - других долбоебов тоже хватает
flat_list = [str(i).replace('Сs-137', 'Cs-137') for i in flat_list]
flat_list = [str(i).replace('Сs-134', 'Cs-134') for i in flat_list]

# # парсирование с учетом переносов
# flat_list = [str(i).replace('Класс \nи код РАО', 'Класс и код РАО') for i in flat_list]
"""


# def get_name_files(lists):
#     """ Функция для извлечения имен файлов """
#     print('Extract name_of_files...')
#     name_of_files = []
#     for my_csv_file in lists:
#         name_of_files.append((my_csv_file.split('/')[-1]).split('.')[0])
#     print('Extracted values (name_of_files): '+ str(len(name_of_files)))
#     return name_of_files